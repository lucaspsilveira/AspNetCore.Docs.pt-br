---
title: Derivação de subchave e criptografia autenticada no ASP.NET Core
author: rick-anderson
description: Aprenda detalhes de implementação de derivação de subchave de proteção de dados ASP.NET Core e criptografia autenticada.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: f373c37a5ea4dab91463d011d3ecd6799ae6d014
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/26/2020
ms.locfileid: "85408026"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="6f5cb-103">Derivação de subchave e criptografia autenticada no ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="6f5cb-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="6f5cb-104">A maioria das chaves no anel de chave conterá alguma forma de entropia e terá informações de algoritmos que informam "criptografia do modo CBC + validação HMAC" ou "GCM criptografia + validação".</span><span class="sxs-lookup"><span data-stu-id="6f5cb-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="6f5cb-105">Nesses casos, nos referimos à entropia incorporada como o material de chaveamento mestre (ou KM) para essa chave, e executamos uma função de derivação de chave para derivar as chaves que serão usadas para as operações de criptografia reais.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="6f5cb-106">As chaves são abstratas e uma implementação personalizada pode não se comportar como a seguir.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="6f5cb-107">Se a chave fornecer sua própria implementação do `IAuthenticatedEncryptor` em vez de usar uma das fábricas internas, o mecanismo descrito nesta seção não se aplicará mais.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="6f5cb-108">Dados autenticados adicionais e derivação de subchave</span><span class="sxs-lookup"><span data-stu-id="6f5cb-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="6f5cb-109">A `IAuthenticatedEncryptor` interface serve como interface principal para todas as operações de criptografia autenticadas.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="6f5cb-110">Seu `Encrypt` método usa dois buffers: texto não criptografado e additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="6f5cb-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="6f5cb-111">O fluxo de conteúdo de texto sem formatação inalterou a chamada para `IDataProtector.Protect` , mas o AAD é gerado pelo sistema e consiste em três componentes:</span><span class="sxs-lookup"><span data-stu-id="6f5cb-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="6f5cb-112">O cabeçalho mágico de 32 bits 09 F0 C9 F0 que identifica esta versão do sistema de proteção de dados.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="6f5cb-113">A ID da chave de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="6f5cb-114">Uma cadeia de caracteres de comprimento variável formada pela cadeia de finalidade que criou a `IDataProtector` que está executando esta operação.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="6f5cb-115">Como o AAD é exclusivo para a tupla de todos os três componentes, podemos usá-lo para derivar novas chaves de KM em vez de usar KM em todas as nossas operações de criptografia.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="6f5cb-116">Para cada chamada para `IAuthenticatedEncryptor.Encrypt` , ocorre o seguinte processo de derivação de chave:</span><span class="sxs-lookup"><span data-stu-id="6f5cb-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="6f5cb-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (K_M, AAD, contextHeader | | keymodificador)</span><span class="sxs-lookup"><span data-stu-id="6f5cb-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="6f5cb-118">Aqui, estamos chamando o NIST SP800-108 KDF no modo de contador (consulte [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1) com os seguintes parâmetros:</span><span class="sxs-lookup"><span data-stu-id="6f5cb-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="6f5cb-119">Chave de derivação de chave (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="6f5cb-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="6f5cb-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="6f5cb-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="6f5cb-121">rótulo = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="6f5cb-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="6f5cb-122">Context = contextHeader | | keymodificador</span><span class="sxs-lookup"><span data-stu-id="6f5cb-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="6f5cb-123">O cabeçalho de contexto é de comprimento variável e, essencialmente, serve como uma impressão digital dos algoritmos para os quais estamos derivando K_E e K_H.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="6f5cb-124">O modificador de chave é uma cadeia de caracteres de 128 bits gerada aleatoriamente para cada chamada para `Encrypt` e serve para garantir que com uma probabilidade impressionante de que ke e KH sejam exclusivos para essa operação de criptografia de autenticação específica, mesmo se todas as outras entradas para o KDF forem constantes.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="6f5cb-125">Para criptografia do modo CBC + operações de validação HMAC, | K_E | é o comprimento da chave de codificação do bloco simétrico e | K_H | é o tamanho de resumo da rotina HMAC.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="6f5cb-126">Para operações de validação e criptografia do GCM, | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="6f5cb-127">Criptografia de modo CBC + validação HMAC</span><span class="sxs-lookup"><span data-stu-id="6f5cb-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="6f5cb-128">Depois que K_E é gerado por meio do mecanismo acima, geramos um vetor de inicialização aleatória e executamos o algoritmo de codificação de bloco simétrico para codificar o texto não criptografado.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="6f5cb-129">O vetor de inicialização e o texto cifrado são executados por meio da rotina HMAC inicializada com a chave K_H para produzir o MAC.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="6f5cb-130">Esse processo e o valor de retorno são representados graficamente abaixo.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-130">This process and the return value is represented graphically below.</span></span>

![Modo CBC-processar e retornar](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="6f5cb-132">*saída: = keymodifier | | IV | | E_cbc (K_E, IV, dados) | | HMAC (K_H, IV | | E_cbc (K_E, IV, dados))*</span><span class="sxs-lookup"><span data-stu-id="6f5cb-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="6f5cb-133">A `IDataProtector.Protect` implementação [precederá o cabeçalho mágico e a ID da chave](xref:security/data-protection/implementation/authenticated-encryption-details) para saída antes de devolvê-lo ao chamador.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="6f5cb-134">Como o cabeçalho mágico e a ID da chave são implicitamente parte do [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), e como o modificador de chave é alimentado como entrada para o KDF, isso significa que cada byte de carga final retornado é autenticado pelo Mac.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="6f5cb-135">Criptografia do modo de Galois/contador + validação</span><span class="sxs-lookup"><span data-stu-id="6f5cb-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="6f5cb-136">Uma vez que K_E é gerado por meio do mecanismo acima, geramos um nonce aleatório de 96 bits e executamos o algoritmo de codificação de bloco simétrico para codificar o texto não criptografado e produzir a marca de autenticação de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Processo e retorno do modo GCM](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="6f5cb-138">*saída: = keymodifier | | Nonce | | E_gcm (K_E, nonce, dados) | | authTag*</span><span class="sxs-lookup"><span data-stu-id="6f5cb-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="6f5cb-139">Embora o GCM nativamente dê suporte ao conceito de AAD, ainda estamos alimentando o AAD somente para o KDF original, optando por passar uma cadeia de caracteres vazia para o seu parâmetro AAD.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="6f5cb-140">A razão para isso é de duas dobras.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-140">The reason for this is two-fold.</span></span> <span data-ttu-id="6f5cb-141">Primeiro, [para dar suporte à agilidade](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) , nunca queremos usar K_M diretamente como a chave de criptografia.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="6f5cb-142">Além disso, o GCM impõe requisitos de exclusividade muito estritos em suas entradas.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="6f5cb-143">A probabilidade de que a rotina de criptografia do GCM seja invocada em dois ou mais conjuntos distintos de dados de entrada com o mesmo par (chave, nonce) não deve exceder 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="6f5cb-144">Se corrigirmos K_E não é possível executar mais de 2 ^ 32 operações de criptografia antes de executarmos afoul do limite de 2 ^-32.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="6f5cb-145">Isso pode parecer um número muito grande de operações, mas um servidor Web de tráfego alto pode passar por 4.000.000.000 solicitações em alguns dias, bem dentro do tempo de vida normal dessas chaves.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="6f5cb-146">Para permanecer em conformidade com o limite de probabilidade de 2 ^-32, continuamos a usar um modificador de chave de 128 bits e um nonce de 96 bits, que estende radicalmente a contagem de operação utilizável para qualquer K_M determinado.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="6f5cb-147">Para simplificar o design, compartilhamos o caminho de código KDF entre as operações CBC e GCM, e como o AAD já é considerado no KDF, não há necessidade de encaminhá-lo à rotina do GCM.</span><span class="sxs-lookup"><span data-stu-id="6f5cb-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
